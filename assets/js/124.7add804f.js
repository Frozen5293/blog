(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{450:function(a,t,v){"use strict";v.r(t);var s=v(8),_=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"图形学概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图形学概念"}},[a._v("#")]),a._v(" 图形学概念")]),a._v(" "),t("h4",{attrs:{id:"图形渲染管线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图形渲染管线"}},[a._v("#")]),a._v(" 图形渲染管线")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("顶点处理：\n    输入顶点\n投影：\n    变换顶点到屏幕上形成三角形，视图变换，\n光栅化：\n    分割成片元【像素】，深度测试，就是现实什么\n着色：\n    对像素颜色进行计算\n")])])]),t("p",[a._v("现代的GPU是可以编程的，这意味着，***顶点***的着色与***像素***的着色由你说了算。")]),a._v(" "),t("h4",{attrs:{id:"着色器的类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#着色器的类型"}},[a._v("#")]),a._v(" 着色器的类型：")]),a._v(" "),t("p",[a._v("顶点着色器与片元着色器\n顶点着色器负责点的变化\n片元着色器负责显示的颜色")]),a._v(" "),t("p",[a._v("那么如果要计算光照的话就从摄像机射出射线,在点尚未发生形变之前,计算光照的情况\n这需要在")]),a._v(" "),t("h4",{attrs:{id:"名词解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#名词解释"}},[a._v("#")]),a._v(" 名词解释")]),a._v(" "),t("p",[a._v("glsl = OpenGL sharding Language")]),a._v(" "),t("p",[a._v("像素 = 片元 = 片段")]),a._v(" "),t("p",[a._v("顶点着色器 = 顶点的颜色如何着色")]),a._v(" "),t("p",[a._v("【像素=片元=片段】着色器= 像素的颜色如何着色")]),a._v(" "),t("p",[a._v("pixel 像素\ntexel 纹素 => 纹理的像素")]),a._v(" "),t("h4",{attrs:{id:"纹理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#纹理"}},[a._v("#")]),a._v(" 纹理")]),a._v(" "),t("p",[a._v("UV = 纹理的描述法，坐标 (U , V)\n通过美工的设计= 纹理无缝衔接的问题")]),a._v(" "),t("h3",{attrs:{id:"运行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行流程"}},[a._v("#")]),a._v(" 运行流程")]),a._v(" "),t("ol",[t("li",[a._v("首先传入数据")]),a._v(" "),t("li",[a._v("做成vao与vbo")]),a._v(" "),t("li",[a._v("编译着色器")]),a._v(" "),t("li",[a._v("绑定着色器")]),a._v(" "),t("li",[a._v("绑定vao")]),a._v(" "),t("li",[a._v("绘制")])]),a._v(" "),t("h3",{attrs:{id:"坐标变化在顶点着色器中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#坐标变化在顶点着色器中"}},[a._v("#")]),a._v(" 坐标变化在顶点着色器中")]),a._v(" "),t("blockquote",[t("p",[a._v("不会发生变化")])]),a._v(" "),t("h3",{attrs:{id:"视图变换需要在片段着色器中编写实际上自动由gpu完成-可以控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#视图变换需要在片段着色器中编写实际上自动由gpu完成-可以控制"}},[a._v("#")]),a._v(" 视图变换需要在片段着色器中编写实际上自动由GPU完成，可以控制")]),a._v(" "),t("blockquote",[t("p",[a._v("因为是对每一个像素操作的")])]),a._v(" "),t("h3",{attrs:{id:"gpu实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gpu实现的"}},[a._v("#")]),a._v(" GPU实现的")]),a._v(" "),t("p",[a._v("多倍采样(Gpu实现)\n深度缓冲(有个buffer,应该可以导出)")]),a._v(" "),t("h3",{attrs:{id:"chatgpt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chatgpt"}},[a._v("#")]),a._v(" ChatGPT")]),a._v(" "),t("p",[t("strong",[a._v('1.在我的"如果我想使用一种奇怪的"透视"方案,比如远大近小,这可以做到吗,需要自定义透视变换吗?如何自定义透视变换"问题中,你的回答我是不是可以总结为不使用GPU自带的透视,而是自己进行计算并将变换前的结果传递给片元着色器,而片元着色器则是通过变换前的计算光照,并通过原始的数据计算材质?')])]),a._v(" "),t("p",[a._v("你的总结基本正确。如果你想实现一种非标准的透视效果，例如远大近小的效果，你可以自定义透视变换，而不是使用GPU自带的标准透视投影矩阵。这样，你可以手动计算变换前的结果并将其传递给片元着色器。在片元着色器中，你可以使用这些变换前的数据来计算光照和材质等效果。")]),a._v(" "),t("p",[a._v("具体步骤可以总结如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("自定义透视变换：构建自己的透视投影矩阵，以实现所需的透视效果，如远大近小。你可以根据你的需求来调整透视矩阵的参数。\n\n在顶点着色器中应用透视变换：在顶点着色器中，使用自定义的透视投影矩阵来将模型从模型空间转换到裁剪空间坐标。将变换前的数据传递给片元着色器。\n\n在片元着色器中进行光照和材质计算：在片元着色器中，使用变换前的数据进行光照、纹理采样、材质计算等操作，以计算最终的颜色。\n")])])]),t("p",[a._v("这样，你可以实现各种自定义的透视效果，并在片元着色器中进行高级的渲染计算，同时保持对渲染管道的完全控制。需要注意的是，自定义透视变换可能需要一些数学和矩阵计算的知识，以确保变换效果符合你的预期。")]),a._v(" "),t("h3",{attrs:{id:"顶点着色器传递的数据到片段着色器会被差值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顶点着色器传递的数据到片段着色器会被差值"}},[a._v("#")]),a._v(" 顶点着色器传递的数据到片段着色器会被差值")]),a._v(" "),t("blockquote",[t("p",[a._v("可以传递平面值")])]),a._v(" "),t("h3",{attrs:{id:"顶点着色器传递的信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顶点着色器传递的信息"}},[a._v("#")]),a._v(" 顶点着色器传递的信息")]),a._v(" "),t("blockquote")])}),[],!1,null,null,null);t.default=_.exports}}]);