(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{446:function(t,a,r){"use strict";r.r(a);var n=r(8),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("h3",{attrs:{id:"卷积神经网络cnn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#卷积神经网络cnn"}},[t._v("#")]),t._v(" 卷积神经网络CNN")]),t._v(" "),a("h3",{attrs:{id:"循环神经网络rnn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环神经网络rnn"}},[t._v("#")]),t._v(" 循环神经网络RNN")]),t._v(" "),a("h3",{attrs:{id:"自动编码器-autoencoder-ae"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动编码器-autoencoder-ae"}},[t._v("#")]),t._v(" 自动编码器（Autoencoder，AE）")]),t._v(" "),a("p",[t._v("结果数据 → 编码器 → 来源数据 → 解码器 → 结果数据")]),t._v(" "),a("p",[t._v("训练思路是"),a("br"),t._v("\n通过数据然后经过一个加密器得到一个特征,这个特征就是模型最后的输入"),a("br"),t._v("\n这个特征可以通过解密器得到原始的数据的数据,这个数据就是最后的结果,\\")]),t._v(" "),a("p",[t._v("这个加密器我们可以自定义比如高斯模糊"),a("br"),t._v("\n这样相当于的标记了数据\\")]),t._v(" "),a("p",[t._v("然后训练这个解码器"),a("br"),t._v('\n这个解码器的判别与delta通过"标记"的数据\\')])])}),[],!1,null,null,null);a.default=e.exports}}]);