(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{452:function(t,s,a){"use strict";a.r(s);var v=a(8),n=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"虚拟内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[t._v("#")]),t._v(" 虚拟内存")]),t._v(" "),s("h4",{attrs:{id:"页面置换算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面置换算法"}},[t._v("#")]),t._v(" 页面置换算法")]),t._v(" "),s("ol",[s("li",[t._v("最佳置换算法(OPT)")])]),t._v(" "),s("blockquote",[s("p",[t._v("每次淘汰的页面永远不被使用\n或者最晚被访问\n性能:最好,无法实现")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("先入先出(FIFO)")])]),t._v(" "),s("blockquote",[s("p",[t._v("先换入的先换出\n性能:时间简单,性能差,可能会出现Belady异常")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("最近最久未使用(LRU)")])]),t._v(" "),s("blockquote",[s("p",[t._v("每次淘汰上一次访问时间最早的\n性能:好,实现困难,开销大?,需要硬件支持")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code")]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"})]),s("ol",{attrs:{start:"4"}},[s("li",[t._v("时钟置换算法(NRU)(改进)(不改进则是没有修改位)")])]),t._v(" "),s("blockquote",[s("p",[t._v("每次访问会将页面的访问位置1\n每次淘汰,会将1置0,0被淘汰换出\n被修改的才会写入外存\n实现: 修改位 访问位 循环链表\n性能:")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("优先级 未被访问 未被修改\n       未被访问 被修改\n       被访问   未被修改\n       被访问   被修改\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h4",{attrs:{id:"进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("驻留集(请求分页系统为进程分配的物理块的集合)\n如果有虚拟内存一般要小于进程的总大小")]),t._v(" "),s("p",[t._v("过小的坏处,频繁缺页")]),t._v(" "),s("p",[t._v("过大的坏处,资源利用率低,多道程序并发度(进程数)下降")])]),t._v(" "),s("li",[s("p",[t._v("工作集\n在一个时间段内实际访问页面的集合,还有窗口来进行判定\n工作集越大则局限性不行,工作集越小则局部性越好")])]),t._v(" "),s("li",[s("p",[t._v("驻留级分配方案\n固定分配 : 驻留级大小不变,分配时决定")]),t._v(" "),s("p",[t._v("可变分配 : 驻留级大小变化,运行时决定")]),t._v(" "),s("p",[t._v("局部置换 : 缺页置换只发生在当前进程")]),t._v(" "),s("p",[t._v("全局置换 : 一个进程的缺页置换可以替换其他进程的页")])]),t._v(" "),s("li",[s("p",[t._v("页面换入时机\n预调页策略")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v(" 根据局部性原理\n \n 一次调入若干相邻的页,命中率50%\n \n 一般只在进入进程使用,由程序员指定\n")])])]),s("p",[t._v("请求调页策略")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v(" 一次一页,不缺不调页\n\n IO开销大\n")])])])]),t._v(" "),s("li",[s("p",[t._v("如何调入内存")]),t._v(" "),s("p",[t._v("内存+兑换区充足:从(磁盘)兑换区调入"),s("strong",[t._v("内存")])]),t._v(" "),s("p",[t._v("内存+兑换区不重组:不被修改的调入内存,需要时再从文件区调入,被修改的则写入兑换区")]),t._v(" "),s("p",[t._v("unix:一次性从文件区调入,使用过的页面则被写入兑换区")])]),t._v(" "),s("li",[s("p",[t._v("问题")]),t._v(" "),s("ol",[s("li",[t._v("抖动的原因\n内存不够,刚换入就要换出")])])])])])}),[],!1,null,null,null);s.default=n.exports}}]);